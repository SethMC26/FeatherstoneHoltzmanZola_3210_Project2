<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Three.js Infinite Starfield</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
      }
      canvas {
        display: block;
      }
    </style>
  </head>
  <body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
      let scene,
        camera,
        renderer,
        stars = [],
        starCount = 1000;

      function init() {
        // Create the scene
        scene = new THREE.Scene();

        // Create the camera
        camera = new THREE.PerspectiveCamera(
          75, // Field of view
          window.innerWidth / window.innerHeight, // Aspect ratio
          0.1, // Near plane
          1000 // Far plane
        );
        camera.position.z = 500; // Move the camera back to see the stars

        // Create the renderer and add it to the document
        renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Create the stars (particles)
        createStars();

        // Handle window resize
        window.addEventListener("resize", onWindowResize, false);

        // Start the animation loop
        animate();
      }

      function createStars() {
        let geometry = new THREE.BufferGeometry();
        let positions = new Float32Array(starCount * 3); // X, Y, Z for each star

        for (let i = 0; i < starCount; i++) {
          // Randomly position the stars within a large cube
          positions[i * 3] = THREE.MathUtils.randFloatSpread(1000); // x
          positions[i * 3 + 1] = THREE.MathUtils.randFloatSpread(1000); // y
          positions[i * 3 + 2] = THREE.MathUtils.randFloat(0, 1000); // z (depth)
        }

        // Set the star positions as geometry
        geometry.setAttribute(
          "position",
          new THREE.BufferAttribute(positions, 3)
        );

        // Create the material for stars (white points)
        let material = new THREE.PointsMaterial({
          color: 0xffffff,
          size: 2, // Size of each point (star)
          sizeAttenuation: true, // Makes the size diminish with distance
        });

        // Create the star particle system
        let starField = new THREE.Points(geometry, material);
        scene.add(starField);
        stars.push(starField);
      }

      function animate() {
        requestAnimationFrame(animate);

        // Move the camera forward through the stars
        stars.forEach((starField) => {
          let positions = starField.geometry.attributes.position.array;
          for (let i = 0; i < positions.length; i += 3) {
            positions[i + 2] -= 2; // Move the star closer along z-axis

            // Reset the star's position if it's behind the camera
            if (positions[i + 2] < 0) {
              positions[i + 2] = 1000; // Reset depth to farthest point
              positions[i] = THREE.MathUtils.randFloatSpread(1000); // Randomize x position
              positions[i + 1] = THREE.MathUtils.randFloatSpread(1000); // Randomize y position
            }
          }
          // Update geometry after modifications
          starField.geometry.attributes.position.needsUpdate = true;
        });

        // Render the scene from the perspective of the camera
        renderer.render(scene, camera);
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      // Initialize the scene
      init();
    </script>
  </body>
</html>
